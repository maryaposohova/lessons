"""КРЕСТИКИ - НОЛИКИ"""

""" 1м делом нужно создать иговое поле. Создаем переменную. в которой будут находиться списки. Сама переменная это список,
внутри нее вложенные списки (3 штуки).
 Первоначально слелаю так, что всеми элементами будут 'звездочки'.
 Если спечатать, то это же и выйдет в консоли:
[['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]
Но на данном этапе это не похоже на поле для игры в крестики-нолики."""

area = [['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]
# print(area)
"""  Но вспоминаем, что мы можем использовать для перебора например списков.
Здесь у нас получается, что для внешнего списка area внутренние списки будут являться его элементами.
     Пишем цикл фор и будем перебирать нашу переменную area. Если я захочу вывести каждый элемент из этого списка,
то мы увидим: 
for i in area:
    print(i)
['*', '*', '*']
['*', '*', '*']
['*', '*', '*']
 И вот это уже болше похоже на поле для игры.
Но для более презентабельного вида я буду использовать звездочку перед i (*i), чтобы избавиться от квадратных скобочек.
for i in area:
    print(*i)
Получится что-то больше похожее на игровое поле:
* * *
* * *
* * *

*i Данная звездочка явл. оператором распаковки. Это будем изучать в 3 модуле, сейчас нужно понимать, 
что поставив эту звездочку перед списком, мы можем получить его в распакованном виде.

И в нашем случае это олично подходит. И реализация крестиков-ноликов с помощью списков выбрана не случайно. на самом
 деле как по мне это одна из наиудобнейших реализаций, 
тк мы можем обращаться к элементам списка и их изменять, если вспоминать предыдущие наши уроки, вспоминать особенности 
списков (мы можем перебирать эти элементы, изменять эти элементы и вот это нам в нашей игре и пригодится.
     Но... поле мы может отрисовывать несколько раз. У нас может возникнуть необходимость отрисовать поле в любой
момент, например, после каждого действия пользователя, поэтому эти деуствия в отдельную функцию:
 назовем ее draw_area и код, который мы создали перенесем в отдельную функцию:

def draw_area():
    for i in area:
        print(*i)
        
 Теперь, что у нас получается?
 Если мы вызывыем нашу функцию
  
draw_area()

мы получаем  нашу функцию   => 

* * *
* * *
* * *       

"""
"""Теперь сделаем небольшое приветствие для пользователей, печатаем после нашего списка  
и выведем еще какие-нибудь линиии

 area = [['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]
print('Добро пожаловать в крестики-нолики')
draw_area()

Получилось так:
Добро пожаловать в крестики-нолики
----------------------------------
* * *
* * *
* * *

Если вспомнить особенности работы со списками и с вложенными списками, то если мы хотим достать какой-то элемент из
нашего списка. нам необходимо написать его имя, открыть квадратные скобочки и указать индекс, т.е. порядковый 
номер элемента, который мы собираемся достать:  area[индекс]

Если я сейчас достану элемент из нашего списка под номером 0:

area = [['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]
print('Добро пожаловать в крестики-нолики')
print('----------------------------------')
draw_area()
print(area[0])

я получу целый список:
Добро пожаловать в крестики-нолики
----------------------------------
* * *
* * *
* * *
['*', '*', '*']

Но меня интересует отдельный элемент, например, если я достану элемент под ногмером 0 из списка под номером 0
area = [['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]
print('Добро пожаловать в крестики-нолики')
print('----------------------------------')
draw_area()
print(area[0][0])    =>
то получу звездочку

Добро пожаловать в крестики-нолики
----------------------------------
* * *
* * *
* * *
*
Давайте я попробую ее заменить, напишем, что данная звездочка, это  крестик Х  -  area[0][0] = "х"  )
и снова добавлю функцию для отрисовки моего поля  -  draw_area()

area = [['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]
print('Добро пожаловать в крестики-нолики')
print('----------------------------------')
draw_area()
area[0][0] = "х"
draw_area()

...В функцию добавим пустой принт, чтобы поля не прилипали.
def draw_area():
    for i in area:
        print(*i)
    print()                                               ...
    
Проверяем, получается так:
 
* * *
* * *
* * *

х * *
* * *
* * *
  
  И я вижу, что у меня самый первый элемент из моего списка заменился на крестик.
Т.е. таким образом, используя вот такое вот двойное обращение, где: 1) я указываю, к какому списку обращаюсб, 
2) к какому элементу в этом списке, я могу реализовать настоящую игру полноценную крестики-нолику, где пользователь 
будет скам вводить номер ряда, номер колонны, в которую он хочет поставить свой знак либо крестик, либо ноликэ

И если заметить. что у нас первое значение первое значение ([0])[] , будет отвечать за ряд, т.е. либо 1, либо 2, либо 3.
А второе значение [][(0]) будет отвечать за колонну, вертикальны, 1.2 или 3. Между area[0][0] = "х" и draw_area()
    
  1 2 3
1 х * *
2 * * *
3 * * *  
И давайте позволим пользователю выбирать, куда он хочет поставить знак.
 
 Для этого создадим две переменные, в которых будем запрашивать пользовательский ввод
Первая будет:
row = int(input('Введите номер строки (1, 2 или 3) '))
Вторая:
column = int(input('Введите номер cnjk,wf (1, 2 или 3) '))
Получится так:
def draw_area():
    for i in area:
        print(*i)
    print()
area = [['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]
print('Добро пожаловать в крестики-нолики')
print('----------------------------------')
draw_area()
area[0][0] = "х"
row = int(input('Введите номер строки (1, 2 или 3) '))
column = int(input('Введите номер cnjk,wf (1, 2 или 3) '))
draw_area()

После того, как пользователь введет, я должен взять соответствующий элемент с таким номером строки и номером столбца
из нашего игрового поля area и поставить туда соответствующий знак. Но значения 1, 2 и 3 я написал сюда не случайно.
  Если вспомнить, что отсчет элементов начинается с 0. Т.е. по факту первый список будет являться списком под номером 0 
  и первый элемент в нем будет являться элементов под номером 0. Но если мы пользователю предложим вводиить с 0, 
  он может немного запутаться, мы же делаем юзерофрендли (дружелюбные) крестики-нолики по отношению к пользователю.
  И чтобы было удобнее, мы сделаем так, чтобы пользователь сразу вводил нужый номер (1, 2 и 3).
  Нам из каждого введенногог значения нужно будет получить нужный нам номер, т.у. из 1 - 0, ИЗ 2 - 1, ИЗ 3 - 2 для 
  корректного обращения к элементам списка. Поэтому я просто после ввода пользователя буду вычитать единичку
  
  row = int(input('Введите номер строки (1, 2 или 3) ')) - 1
column = int(input('Введите номер cnjk,wf (1, 2 или 3) ')) - 1

И теперь, после того, как пользователь ввел соответственно номера строки и столбца я могу написать, 
что вот есть  мое игровое поле area, я достаю из такой то строки (row) и из такого то  столбца (column) и меняю его
допустим на х.

Получилось так:

def draw_area():
    for i in area:
        print(*i)
    print()


area = [['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]
print('Добро пожаловать в крестики-нолики')
print('----------------------------------')
draw_area()
row = int(input('Введите номер строки (1, 2 или 3) ')) - 1
column = int(input('Введите номер cnjk,wf (1, 2 или 3) ')) - 1
area[0][0] = "х"
area[row][column] = "х"
draw_area() 

Запускаем 
=>

Введите номер строки (1, 2 или 3) 2
Введите номер cnjk,wf (1, 2 или 3) 3
х * *
* * х
* * *

Т.о. у нас положено начало для игры в крестики-нолики
Но... у нас есть некая проблема: 
1) нам нужн менять эти значения, крестик или нолик
2)у нас программа должна повторяться не один раз

Значит здесь мы можем использовать цикл и использовать условия для определения того, кто сейчас  ходит.
Реализовывыть мы можем с помощью цикла вайл и с помощью цикла фор. способ с вайл выглядит самым очевидным, 
но я хочу продемонстрировать способ с циклом фор.

Т.е. после того, как у нас программа поприветствовала пользователя, отрисовала игровое поле, здесь мы создадим цикл фор .
т.е. после первой функции отрисовки поля draw_area().
Делаем цикл фор на 9 повторений. 9 потому, что у нас максимальное кол-во с полем 3х3 может быть только 9.
Максимальное колво ходов может быть 9. Т.е. 9 ходов это в худшем случае, если у нас ничья. Обычно они заканчиваются 
быстрее. Ног мы берем с рачетом на ничью тоже, поэтому берем 9 повторений.

И здесь я обозначу переменную не i, а turn, чтобы вам было понятно
for turn in range(1, 10):

и опираясь на эту переменную мы сможем реализовать смену игрока, кто у нас ходит. Инпуты переносим в фор:

area = [['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]
print('Добро пожаловать в крестики-нолики')
print('----------------------------------')
draw_area()
for turn in range(1, 10):
    
    row = int(input('Введите номер строки (1, 2 или 3) ')) - 1
    column = int(input('Введите номер cnjk,wf (1, 2 или 3) ')) - 1
area[0][0] = "х"
area[row][column] = "х"
draw_area()

Вот эта turn будет у меня определяющим фактором. Здесь я даже выведу информацию, с помощью ф строки. f-строка нам 
позволяет обращаться к переменным прямо внутри строки. Меня интересует моя переменная turn.
for turn in range(1, 10):
    print(f'ход: {turn}')
    
    def draw_area():
    for i in area:
        print(*i)
    print()

Получилось так:
area = [['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]
print('Добро пожаловать в крестики-нолики')
print('----------------------------------')
draw_area()
for turn in range(1, 10):
    print(f'ход: {turn}')
    row = int(input('Введите номер строки (1, 2 или 3) ')) - 1
    column = int(input('Введите номер cnjk,wf (1, 2 или 3) ')) - 1
area[row][column] = "х"
draw_area()

Т.е. у нас ход № такой-то. И вот чтобы реализовать вот эту смену нам нужно проверять 
(Он пока что  удалил или вырезал area[row][column] = "х" и передвинул вторую копию функции на 1 таб)
area = [['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]
print('Добро пожаловать в крестики-нолики')
print('----------------------------------')
draw_area()
for turn in range(1, 10):
    print(f'ход: {turn}')
    row = int(input('Введите номер строки (1, 2 или 3) ')) - 1
    column = int(input('Введите номер cnjk,wf (1, 2 или 3) ')) - 1
                                                             # area[row][column] = "х" (вырезал или удалил)
    draw_area()                                              # (передвинул)


Вот эту смену нам нужно проверять первыми, у нас же ход начинается с первого. 
Первым обычно ходят крестики. А вторым ходят нолики.

Если нолики ходят вторыми, значит они в следующий раз пойдут 4, 6, 8 ...
Т.е. получается у нас нолики ходят на четных ходах, а крестики на нечетных.
Значит нам необходимо завести особую переменную, которая будет принимать значения того, кто сейчас ходит. 
И в зависимости от четного или нечетного мы будем устанавливать значения этой переменной.
Т.е. если наш ход четный, то данный ход ход будет ноликом. И тут мы выведем информацию "ходят нолики"
 if turn % 2 == 0:
        turn_char = '0'
        print('Ходят нолики')
        
Вот так получилось(выше не забыть про def-функцию)
area = [['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]
print('Добро пожаловать в крестики-нолики')
print('----------------------------------')
draw_area()
for turn in range(1, 10):
    print(f'ход: {turn}')
    if turn % 2 == 0:
        turn_char = '0'
        print('Ходят нолики')
    row = int(input('Введите номер строки (1, 2 или 3) ')) - 1
    column = int(input('Введите номер cnjk,wf (1, 2 или 3) ')) - 1
area[row][column] = turn_char
draw_area()

Также после ифа, где мы указали, что если ход четный, он будет обозначен как "0" (переменной turn_char = '0'), 
замем пишем элсе, где укажем, что в любом другом случае, т.е. ход четный и будет обозначен "x".

И в у строку, где у нас написаны были индексы строки и колонки, которую он удалил, мы впишем нашу переменную turn_char
Получился такой код:

def draw_area():               #   функция, поле
    for i in area:
        print(*i)
    print()


area = [['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]
print('Добро пожаловать в крестики-нолики')
print('----------------------------------')
draw_area()
for turn in range(1, 10):
    print(f'ход: {turn}')
    if turn % 2 == 0:
        turn_char = '0'
        print('Ходят нолики')
    else:
        turn_char = 'х'
        print('Ходят крестики')
    row = int(input('Введите номер строки (1, 2 или 3) ')) - 1
    column = int(input('Введите номер столбца (1, 2 или 3) ')) - 1
    area[row][column] = turn_char
    draw_area()
 
 =>   
    ход: 2
Ходят нолики
Введите номер строки (1, 2 или 3) 2
Введите номер столбца (1, 2 или 3) 2
х * *
* 0 *
* * *

ход: 3
Ходят крестики
Введите номер строки (1, 2 или 3) 

       Здорово, все работает, но у нас есть некая проблемка. Сейчас на третьем ходе ходят крестики, 
если я укажу те же координаты, где уже стоит 0, то он просто заменится на х и ход потратился. Такого быть не должно.
Т.е. нам надо реализовать прповерку ячейки на занятость, взависимости от этого определять, будем ли мы ставить 
там или нет.
Поэтому прежде, чем поставить сюда символ на соответствующую ячейку (про эту строку - area[row][column] = turn_char  ), 
 мы будем проверять ифом, что если в нашем поле на такой-то строке, на таком-то столбце  находится "*" (потому что 
 список у нас изначально состоит из *), то в таком случае я ставлю на это место (на место переменной turn_char) 
 символ того, кто сейчас ходит. Это второй строчкой в ифе. Но в другом случае (в елсе) я буду выводить сообщение о том, 
 что у нас ячейка уже занята, можно еще сказать, что пользователь будет пропускать ход.
  
   #area[row][column] = turn_char # здесь проверяем ячейку на занятость.
    if area[row][column] == "*":
        area[row][column] = turn_char
    else:
        print('Ячейка уже занята, вы прпопускаете ход')
        draw_area()
        
Сделаем так, потому, что это интересней, и мы можем воспользоваться одной из команд, которую мы разбирали, 
когда работали с циклами. Т.е. у нас же есть continue, которая пропускает выполнение всех остаьных команд. 
Просто ставим ее после принта с сообщением о пропуске хода и действие переходит к следующей итерации цикла.

Давайте проерять этот код:

def draw_area():
    for i in area:
        print(*i)
    print()


area = [['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]
print('Добро пожаловать в крестики-нолики')
print('----------------------------------')
draw_area()
for turn in range(1, 10):
    print(f'ход: {turn}')
    if turn % 2 == 0:
        turn_char = '0'
        print('Ходят нолики')
    else:
        turn_char = 'х'
        print('Ходят крестики')
    row = int(input('Введите номер строки (1, 2 или 3) ')) - 1
    column = int(input('Введите номер столбца (1, 2 или 3) ')) - 1
    #area[row][column] = turn_char # здесь проверяем ячейку на занятость.
    if area[row][column] == "*":
        area[row][column] = turn_char
    else:
        print('Ячейка уже занята, вы прпопускаете ход')
        continue
    draw_area()
    
    
    Все работает.
    
    И едиственный нюанс: у нас не сработала отрисовка поля в каждом ходе. У меня сработала отрисовка.
    А он поставил функцию поля - draw_area() перед continue:
        else:
        print('Ячейка уже занята, вы пропускаете ход')
        draw_area()
        continue
    draw_area()
    
     Но у меня сработало без этого, но почему-то на других ходах перестало срабатывать новое поле, 
     и я поставила тоже фуккцию после принта и перед континью.
  =>
Добро пожаловать в крестики-нолики
----------------------------------
* * *
* * *
* * *

ход: 1
Ходят крестики
Введите номер строки (1, 2 или 3) 1
Введите номер столбца (1, 2 или 3) 1
х * *
* * *
* * *

ход: 2
Ходят нолики
Введите номер строки (1, 2 или 3) 1
Введите номер столбца (1, 2 или 3) 2
х 0 *
* * *
* * *

ход: 3
Ходят крестики
Введите номер строки (1, 2 или 3) 1
Введите номер столбца (1, 2 или 3) 2
Ячейка уже занята, вы пропускаете ход
ход: 4
  
    
"""


def draw_area():
    for i in area:
        print(*i)
    print()


area = [['*', '*', '*'], ['*', '*', '*'], ['*', '*', '*']]
print('Добро пожаловать в крестики-нолики')
print('----------------------------------')
draw_area()
for turn in range(1, 10):
    print(f'ход: {turn}')
    if turn % 2 == 0:
        turn_char = '0'
        print('Ходят нолики')
    else:
        turn_char = 'х'
        print('Ходят крестики')
    row = int(input('Введите номер строки (1, 2 или 3) ')) - 1
    column = int(input('Введите номер столбца (1, 2 или 3) ')) - 1
    #area[row][column] = turn_char # здесь проверяем ячейку на занятость.
    if area[row][column] == "*":
        area[row][column] = turn_char
    else:
        print('Ячейка уже занята, вы пропускаете ход')
        draw_area()
        continue
    draw_area()




